---
title: Koa2中实现一个登录有效时间可刷新的jwt策略
date: 2019-03-26 10:15:53
tags:
- NodeJs
- Koa
categories:
- 零碎点
---

#### JWT策略
通常在做权限控制的时候，会用到jwt策略（json web token），在Koa中jwt大致实现思路是:

- 用户登录时将username和password（MD5加密后）与数据库匹配后取出用户数据、
- 确定一个用户信息唯一标识符，作为key（通常是email或者userId），将用户信息储存在redis中
- 用``jsonwebtoken`` + 预定好的秘钥加密令牌（通常是email或者userId的键值对），设置过期时间

``` javascript
const jwt = require('jsonwebtoken');

await redis.set(result.email, JSON.stringify(result)); // result是匹配成功后从数据库取出的用户数据
const token = jwt.sign({email: result.email}, cfg.TOKEN_SECRET, {expiresIn: '2h'}); // 生成加密token
```

- 返回前端加密好的token，并在前端调用接口的时候通过header传递回来
- 在洋葱圈最外层增加一个jwt错误处理中间件，和一个jwt中间件（可以设置直接通行不受jwt限制的路由），匹配上的路由（又不在unless里），会被``koa-jwt``中间件进行处理，如果没有token或token失效，则``koa-jwt``中间件会抛出401异常，被外层错误处理中间件捕获，返回前端授权失败信息

``` javascript
const jwtKoa = require('koa-jwt');

// jwt错误处理
app.use((ctx, next) => {
    return next().catch((err) => {
        console.error(err);
        if(err.status === 401){
            ctx.status = 401;
            ctx.body = 'Protected resource, use Authorization header to get access\n';
        }else{
            throw err;
        }
    })
});

// 初始化koa-jwt
app.use(jwtKoa({secret: cfg.TOKEN_SECRET}).unless({path: [/^\/auth\//, /^\/public\//, /\/statistics\/getSurveyStatisticsData/]}));
```

- 在路由前另写一个中间件：使用预定好的秘钥解密token，如果解不出来，则token过期，能解出来，则通过令牌值去redis中取用户数据，挂载在ctx下

> router.js

``` javascript
const Router = require('koa-router');
const tokenParser = require('../middleware/token-parser');

const router = new Router();
router.use(tokenParser);
```

> token-parser.js

``` javascript
const jwt = require('jsonwebtoken');
const util = require('util');
const verify = util.promisify(jwt.verify) ;// 将解密方法返回值转成Promise对象

module.exports = async (ctx, next) => {
    const token = ctx.header.authorization; // 获取token
    if(token){
        const infoKey = await verify(token.split(' ')[1], cfg.TOKEN_SECRET); // 解密，获取infoKey
        let userInfo = await redis.get(infoKey.email); // 用infoKey作为键 去redis中取用户信息。
        if(!userInfo) { // 若redis中没有对应的用户信息，也提示token已失效
            resp.sendAuthFailedResponse(ctx, 'token已过期'); // resp是封装的返回响应工具类
            return;
        }
    }
    ctx.userInfo = JSON.parse(userInfo);//把用户信息存到请求的上下文中。
};
```

> <font color="#fc6423">这里的解密其实画蛇添足了，我被网上的写法误导了(╯°□°）╯︵ ┻━┻，实际上不需要再手动解密获取``infoKey``，我阅读``koa-jwt``源码后发现，它已经将token解密，并且将解密后的键值对挂载在``ctx.state.user``上了，也可以更换挂载的key,例如在初始化``koa-jwt``时传入配置项``key: 'infoKey'``，则``koa-jwt``会把解密后的token挂载在``ctx.state.infoKey``上</font>
