---
title: Koa2中实现一个登录有效时间可刷新的jwt策略
date: 2019-03-26 10:15:53
tags:
- NodeJs
- Koa
categories:
- 零碎点
---

#### JWT策略

通常在做权限控制的时候，会用到jwt策略（json web token），在Koa中jwt大致实现思路是:

- 用户登录时将username和password（MD5加密后）与数据库匹配后取出用户数据
- 确定一个用户信息唯一标识符，作为key（通常是email或者userId），将用户信息储存在redis中
- 用``jsonwebtoken`` + 预定好的秘钥加密令牌（通常是email或者userId的键值对），设置过期时间

``` javascript
const jwt = require('jsonwebtoken');

await redis.set(result.email, JSON.stringify(result)); // result是匹配成功后从数据库取出的用户数据
const token = jwt.sign({ email: result.email }, cfg.TOKEN_SECRET, { expiresIn: '2h' }); // 生成加密token
```

- 返回前端加密好的token，并在前端调用接口的时候通过header传递回来
- 在洋葱圈最外层增加一个jwt错误处理中间件，和一个jwt中间件（可以设置直接通行不受jwt限制的路由），匹配上的路由（又不在unless里），会被``koa-jwt``中间件进行处理，如果没有token或token失效，则``koa-jwt``中间件会抛出401异常，被外层错误处理中间件捕获，返回前端授权失败信息

``` javascript
const jwtKoa = require('koa-jwt');

// jwt错误处理
app.use((ctx, next) => {
    return next().catch((err) => {
        console.error(err);
        if(err.status === 401) {
            ctx.status = 401;
            ctx.body = 'Protected resource, use Authorization header to get access\n';
        }
        else {
            throw err;
        }
    })
});

// 初始化koa-jwt
app.use(jwtKoa({secret: cfg.TOKEN_SECRET}).unless({path: [/^\/auth\//, /^\/public\//, /\/statistics\/getSurveyStatisticsData/]}));
```

- 在路由前另写一个中间件：使用预定好的秘钥解密token，如果解不出来，则token过期，能解出来，则通过令牌值去redis中取用户数据，挂载在ctx下

> router.js

``` javascript
const Router = require('koa-router');
const tokenParser = require('../middleware/token-parser');

const router = new Router();
router.use(tokenParser);
```

> token-parser.js

``` javascript
const jwt = require('jsonwebtoken');
const util = require('util');
const verify = util.promisify(jwt.verify) ;// 将解密方法返回值转成Promise对象

module.exports = async (ctx, next) => {
    const token = ctx.header.authorization; // 获取token
    if(token) {
        const infoKey = await verify(token.split(' ')[1], cfg.TOKEN_SECRET); // 解密，获取infoKey
        let userInfo = await redis.get(infoKey.email); // 用infoKey作为键 去redis中取用户信息。
        if(!userInfo) { // 若redis中没有对应的用户信息，也提示token已失效
            resp.sendAuthFailedResponse(ctx, 'token已过期'); // resp是封装的返回响应工具类
            return;
        }
    }
    ctx.userInfo = JSON.parse(userInfo);//把用户信息存到请求的上下文中。
};
```

> <font color="#fc6423">这里的解密其实画蛇添足了，我被网上的写法误导了(╯°□°）╯︵ ┻━┻，实际上不需要再手动解密获取``infoKey``，我阅读``koa-jwt``源码后发现，它已经将token解密，并且将解密后的键值对挂载在``ctx.state.user``上了，也可以更换挂载的key，例如在初始化``koa-jwt``时传入配置项``key: 'infoKey'``，则``koa-jwt``会把解密后的token挂载在``ctx.state.infoKey``上</font>

***

#### 为什么要自己实现一个JWT策略

1. ``jsonwebtoken``包生成的token不能刷新有效时间，也就是一旦我生成一个有效期2小时的token，那么它2小时后必定过期，哪怕我在1小时59分的时候还调过服务端的接口，也没法保持自己的登录状态。因为本次后台系统项目业务需求，期望在确认用户活跃的情况下始终保持登录状态（即只要调服务接口，有效期就重置），所以``jsonwebtoken``不能满足业务需求
2. ``jsonwebtoken``生成token后，是保存在服务器的内存中的，如果服务器宕机，则所有用户的登录状态都会消失
3. 本次项目是针对内部人员使用的系统，所以安全性要求并没有那么高

***

#### 动手模拟一个简单的JWT策略

- 用户登录时将username和password（MD5加密后）与数据库匹配后取出用户数据
- 使用邮箱 + 时间戳制作一个infoKey，利用redis有效时间的可控性实现token过期逻辑
- 用系统自带的aes加密infoKey，返回前端加密后的token

``` javascript
// 配置信息
const cfg = require('iqs-config');
// 自己写的响应、redis、aes加密、工具类
const { resp, redis, aesUtil } = require('iqs-utils');
// npm安装的md5包
const md5 = require('md5');

/**
 * 登录接口
 * @param ctx
 * @returns {Promise<void>}
 */
const signIn = async (ctx) => {
    const data = ctx.request.body;
    if (!data.email || !util.isEmail(data.email)) {
        resp.sendArgMissingResponse(ctx, '邮箱账号无效');
        return;
    }
    if (!data.password || data.password.length < 6 || data.password.length > 20){
        resp.sendArgMissingResponse(ctx, '密码为空或不符合规定');
        return;
    }

    // 取出用户数据
    const result = await UserModel.findOne({
        email: data.email,
        password: md5(data.password)
    });
    if (result === null) {
        resp.sendAuthFailedResponse(ctx, '0101','用户名或密码错误');
        return;
    }

    // 设置infoKey并且用aes加密生成token，将用户信息存在redis中，设置8小时过期
    const infoKey = result.email + Date.now();
    const token = aesUtil.encrypt(infoKey, cfg.TOKEN_SECRET);
    await redis.set(infoKey, JSON.stringify(result),  8 * 3600);

    // 返回前端部分需要的信息，以及token
    resp.sendSuccessResponse(ctx, {
        name: result.name,
        level: result.level,
        uuid: result._id,
        token: token,
        deptCode1: result.deptCode1,
        deptName1: result.deptName1,
        deptCode2: result.deptCode2,
        deptName2: result.deptName2,
        deptCode3: result.deptCode3,
        deptName3: result.deptName3,
    });
};
```

- 在路由前编写一个校验token的中间件
- 模拟通行不受限制的路由匹配
- 当前端携带token请求任意需要token的接口，重置token有效时间

> <font color="#fc6423">router.js</font>

``` javascript
const Router = require('koa-router');
const tokenParser = require('../middleware/token-parser');

const router = new Router();
router.use(tokenParser);
// 开始匹配路由

module.exports = router;
```

> <font color="#fc6423">token-parser.js</font>

``` javascript
const cfg = require('iqs-config');
const { aesUtil, redis, resp } = require('iqs-utils');

module.exports = async (ctx, next) => {
    //免token登录
    const ignoreToken = [/^\/auth\//, /^\/public\//, /\/statistics\/getSurveyStatisticsData/].some(reg => {
        return reg.test(ctx.request.url);
    });
    if (ignoreToken) {
        await next();
        return;
    }
    const token = ctx.header.authorization;
    if ( !token) {
        resp.sendAuthFailedResponse(ctx, '0003', '安全认证信息有误');
        return;
    }
    const infoKey = aesUtil.decrypt(token, cfg.TOKEN_SECRET);//解密，获取key
    let userInfo = await redis.get(infoKey); //用infoKey作为键 去redis中取用户信息。
    if(!userInfo) {//若redis中没有对应的用户信息，则表示token已失效
        resp.sendAuthFailedResponse(ctx, '0003', 'token已过期');
        return;
    }
    ctx.userInfo = JSON.parse(userInfo);//把用户信息存到请求的上下文中。
    await redis.set(infoKey, userInfo, 8 * 3600);//更新token时效
    await next();
};
```

***

完结撒花~